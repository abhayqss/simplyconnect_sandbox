package com.scnsoft.eldermark.service.document.templates.ccd.factory.sections;

import com.scnsoft.eldermark.entity.Client;
import com.scnsoft.eldermark.entity.document.CcdCode;
import com.scnsoft.eldermark.entity.document.ccd.CodeSystem;
import com.scnsoft.eldermark.entity.document.ccd.Result;
import com.scnsoft.eldermark.entity.document.ccd.ResultObservation;
import com.scnsoft.eldermark.service.document.cda.CcdCodeFactory;
import com.scnsoft.eldermark.service.document.templates.ccd.factory.entries.CcdSectionEntryFactory;
import com.scnsoft.eldermark.service.document.templates.ccd.parser.entries.SectionEntryParseFactory;
import com.scnsoft.eldermark.service.document.templates.cda.factory.sections.RequiredTemplateFactory;
import com.scnsoft.eldermark.service.document.templates.cda.parser.entries.ObservationFactory;
import com.scnsoft.eldermark.service.document.templates.cda.parser.sections.ParsableSectionFactory;
import com.scnsoft.eldermark.util.cda.CcdParseUtils;
import com.scnsoft.eldermark.util.cda.CcdTransform;
import com.scnsoft.eldermark.util.cda.CcdUtils;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.lang.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.eclipse.mdht.uml.cda.CDAFactory;
import org.eclipse.mdht.uml.cda.Entry;
import org.eclipse.mdht.uml.cda.Observation;
import org.eclipse.mdht.uml.cda.Organizer;
import org.eclipse.mdht.uml.hl7.datatypes.*;
import org.openhealthtools.mdht.uml.cda.ccd.CCDFactory;
import org.openhealthtools.mdht.uml.cda.ccd.ResultsSection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * <h1>Results</h1> “This section contains the results of observations generated
 * by laboratories, imaging procedures, and other procedures ... The section may
 * contain all results for the period of time being summarized, but should
 * include notable results such as abnormal values or relevant trends.” [CCD
 * 3.13].
 * <p>
 * Laboratory results are typically generated by laboratories providing analytic
 * services in areas such as chemistry, hematology, serology, histology,
 * cytology, anatomic pathology, microbiology, and/or virology. These
 * observations are based on analysis of specimens obtained from the patient and
 * submitted to the laboratory. Imaging results are typically generated by a
 * clinician reviewing the output of an imaging procedure, such as where a
 * cardiologist reports the left ventricular ejection fraction based on the
 * review of a cardiac echocardiogram.
 * <p>
 * Procedure results are typically generated by a clinician to provide more
 * granular information about component observations made during a procedure,
 * such as where a gastroenterologist reports the size of a polyp observed
 * during a colonoscopy.
 *
 * @see Result
 * @see ResultObservation
 * @see CcdCode
 * @see Client
 */
@Component(value = "resultFactory")
public class ResultsFactory extends RequiredTemplateFactory implements ParsableSectionFactory<ResultsSection, Result> {

    private static CcdSectionEntryFactory ccdSectionEntryFactory = CcdSectionEntryFactory.INSTANCE;

    @Autowired
    private CcdCodeFactory ccdCodeFactory;

    @Autowired
    private SectionEntryParseFactory sectionEntryParseFactory;

    @Override
    public ResultsSection buildTemplateInstance(Collection<Result> results) {
        final ResultsSection section = CCDFactory.eINSTANCE.createResultsSection();
        section.getTemplateIds().add(DatatypesFactory.eINSTANCE.createII("2.16.840.1.113883.10.20.1.14"));

        CE sectionCode = CcdUtils.createCE("30954-2", "RESULTS", CodeSystem.LOINC);
        section.setCode(sectionCode);

        ST title = DatatypesFactory.eINSTANCE.createST();
        title.addText("Results");
        section.setTitle(title);

        section.createStrucDocText(buildSectionText(results));

        if (CollectionUtils.isEmpty(results)) {
            Entry entry = CDAFactory.eINSTANCE.createEntry();
            entry.setOrganizer(ccdSectionEntryFactory.buildNullResultOrganizer());
            section.getEntries().add(entry);

            return section;
        }

        for (Result result : results) {
            Entry entry = CDAFactory.eINSTANCE.createEntry();
            entry.setOrganizer(ccdSectionEntryFactory.buildResultOrganizer(result));
            section.getEntries().add(entry);
        }

        return section;
    }

    private static String buildSectionText(Collection<Result> results) {

        if (CollectionUtils.isEmpty(results)) {
            return "No known results.";
        }

        StringBuilder sectionText = new StringBuilder("<table>" +
                "<thead>" +
                "<tr>" +
                "<th>Result Date</th>" +
                "<th>Result Type</th>" +
                "<th>Result Status</th>" +
                "<th>Result Value</th>" +
                "<th>Result Interpretations</th>" +
                "<th>Result Reference Ranges</th>" +
                "</tr>" +
                "</thead>");

        var body = new StringBuilder();

        for (Result result : results) {
            if (CollectionUtils.isNotEmpty(result.getObservations())) {
                for (ResultObservation resultObservation : result.getObservations()) {
                    body.append("<tr>");

                    CcdUtils.addDateCell(resultObservation.getEffectiveTime(), body);

                    body.append("<td>");
                    if (resultObservation.getText() != null) {
                        CcdUtils.addReferenceToSectionText(
                                ResultObservation.class.getSimpleName() + resultObservation.getId(),
                                resultObservation.getText(), body);
                    } else {
                        CcdUtils.addEmptyCellToSectionText(body);
                    }
                    body.append("</td>");

                    body.append("<td>");
                    if (StringUtils.isNotEmpty(resultObservation.getStatusCode())) {
                        body.append(StringEscapeUtils.escapeHtml(resultObservation.getStatusCode()));
                    } else {
                        CcdUtils.addEmptyCellToSectionText(body);
                    }
                    body.append("</td>");

                    body.append("<td>");
                    if (resultObservation.getValue() != null && resultObservation.getValueUnit() != null) {
                        body.append(StringEscapeUtils
                                .escapeHtml(resultObservation.getValue() + ", " + resultObservation.getValueUnit()));
                    } else {
                        CcdUtils.addEmptyCellToSectionText(body);
                    }
                    body.append("</td>");

                    body.append("<td>");
                    if (CollectionUtils.isNotEmpty(resultObservation.getInterpretationCodes())) {
                        String prefix = "";
                        for (CcdCode interpretationCode : resultObservation.getInterpretationCodes()) {
                            if (interpretationCode.getDisplayName() != null) {
                                body.append(prefix);
                                body.append(StringEscapeUtils.escapeHtml(interpretationCode.getDisplayName()));
                                prefix = "; ";
                            }
                        }
                    } else {
                        CcdUtils.addEmptyCellToSectionText(body);
                    }
                    body.append("</td>");

                    body.append("<td>");
                    if (CollectionUtils.isNotEmpty(resultObservation.getReferenceRanges())) {
                        String prefix = "";
                        for (String referenceRange : resultObservation.getReferenceRanges()) {
                            body.append(prefix);
                            body.append(StringEscapeUtils.escapeHtml(referenceRange));
                            prefix = "; ";
                        }
                    } else {
                        CcdUtils.addEmptyCellToSectionText(body);
                    }
                    body.append("</td>");

                    body.append("</tr>");
                }
            }
        }

        if (body.length() == 0) {
            return "No known results.";
        }

        CcdUtils.addContent(sectionText, body, CcdUtils.ContentTag.TBODY);
        sectionText.append("</table>");

        return sectionText.toString();
    }

    private Result parseResultOrganizer(Organizer ccdOrganizer, Client client) {
        if (!CcdParseUtils.hasContent(ccdOrganizer) || client == null) {
            return null;
        }
        checkNotNull(client);

        Result result = new Result();
        result.setClient(client);
        result.setOrganization(client.getOrganization());
        result.setLegacyId(CcdParseUtils.getFirstIdExtension(ccdOrganizer.getIds()));

        result.setCode(ccdCodeFactory.convert(ccdOrganizer.getCode()));
        if (CcdParseUtils.hasContent(ccdOrganizer.getStatusCode())) {
            result.setStatusCode(ccdOrganizer.getStatusCode().getCode());
        }

        // Read the above comment for @classCode
        result.setClassCode(ccdOrganizer.getClassCode().getName());

        if (!CollectionUtils.isEmpty(ccdOrganizer.getObservations())) {
            List<ResultObservation> resultObservations = new ArrayList<ResultObservation>();
            for (Observation ccdObservation : ccdOrganizer.getObservations()) {
                ResultObservation resultObservation = parseResultObservation(ccdObservation, client);
                if (resultObservation != null) {
                    resultObservations.add(resultObservation);
                }
            }
            result.setObservations(resultObservations);
        }

        if (!CollectionUtils.isEmpty(ccdOrganizer.getProcedures())) {
            // TODO : parse and store procedures ?
        }

        return result;
    }

    private ResultObservation parseResultObservation(Observation ccdObservation, Client client) {
        if (!CcdParseUtils.hasContent(ccdObservation) || client == null) {
            return null;
        }
        checkNotNull(client);

        ResultObservation resultObservation = new ResultObservation();
        resultObservation.setOrganization(client.getOrganization());

        CD code = ccdObservation.getCode();
        resultObservation.setResultTypeCode(ccdCodeFactory.convert(code));
        resultObservation
                .setText(CcdTransform.EDtoString(code.getOriginalText(), resultObservation.getResultTypeCode()));

        if (CcdParseUtils.hasContent(ccdObservation.getStatusCode())) {
            resultObservation.setStatusCode(ccdObservation.getStatusCode().getCode());
        }

        // Effective time data type may be TS or IVL<TS>
        resultObservation.setEffectiveTime(CcdParseUtils.parseCenterTime(ccdObservation.getEffectiveTime()));
        if (resultObservation.getEffectiveTime() == null
                && CcdParseUtils.hasContent(ccdObservation.getEffectiveTime())) {
            resultObservation.setEffectiveTime(CcdParseUtils.convertTsToDate(ccdObservation.getEffectiveTime()));
        }

        if (!CollectionUtils.isEmpty(ccdObservation.getMethodCodes())) {
            resultObservation.setMethodCode(ccdCodeFactory.convert(ccdObservation.getMethodCodes().get(0)));
        }
        if (!CollectionUtils.isEmpty(ccdObservation.getTargetSiteCodes())) {
            resultObservation.setTargetSiteCode(ccdCodeFactory.convert(ccdObservation.getTargetSiteCodes().get(0)));
        }
        if (!CollectionUtils.isEmpty(ccdObservation.getAuthors())) {
            resultObservation.setAuthor(
                    sectionEntryParseFactory.parseAuthor(ccdObservation.getAuthors().get(0), client, "Results_NWHIN"));
        }

        resultObservation.setInterpretationCodes(ccdCodeFactory.convertInterpretationCodes(ccdObservation));

        resultObservation
                .setReferenceRanges(SectionEntryParseFactory.parseReferenceRanges(ccdObservation.getReferenceRanges()));

        try {
            // Observation value data may be of ANY type?
            // TODO change value type to Double in order to store ST values as well
            PQ observationValue = ObservationFactory.getValue(ccdObservation, PQ.class);
            if (observationValue != null) {
                resultObservation.setValue(CcdTransform.PQtoInteger(observationValue));
                resultObservation.setValueUnit(observationValue.getUnit());
            }
        } catch (ClassCastException exc) {

        }

        return resultObservation;
    }

    @Override
    public List<Result> parseSection(Client client, ResultsSection resultsSection) {
        if (!CcdParseUtils.hasContent(resultsSection) || CollectionUtils.isEmpty(resultsSection.getEntries())) {
            return Collections.emptyList();
        }
        checkNotNull(client);

        final List<Result> results = new ArrayList<>();
        for (Entry ccdResultEntry : resultsSection.getEntries()) {
            final Result result = parseResultOrganizer(ccdResultEntry.getOrganizer(), client);
            if (result != null) {
                results.add(result);
            }
        }

        return results;
    }

}