package com.scnsoft.eldermark.services.consol.templates.sections;

import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;
import com.scnsoft.eldermark.entity.CcdCode;
import com.scnsoft.eldermark.entity.Resident;
import com.scnsoft.eldermark.entity.Result;
import com.scnsoft.eldermark.entity.ResultObservation;
import com.scnsoft.eldermark.services.cda.CcdCodeFactory;
import com.scnsoft.eldermark.services.cda.templates.AbstractParsableSection;
import com.scnsoft.eldermark.services.cda.util.CcdParseUtils;
import com.scnsoft.eldermark.services.cda.templates.ParsableSection;
import com.scnsoft.eldermark.services.cda.templates.sections.entries.ResultObservationFactory;

import org.apache.commons.lang.StringUtils;
import org.eclipse.mdht.uml.cda.Observation;
import org.eclipse.mdht.uml.hl7.datatypes.CS;
import org.eclipse.mdht.uml.hl7.vocab.NullFlavor;
import org.openhealthtools.mdht.uml.cda.consol.ResultOrganizer;
import org.openhealthtools.mdht.uml.cda.consol.ResultsSection;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * <h1>Results</h1> “This section contains the results of observations generated
 * by laboratories, imaging procedures, and other procedures ... The section may
 * contain all results for the period of time being summarized, but should
 * include notable results such as abnormal values or relevant trends.” [CCD
 * 3.13].
 *
 * Laboratory results are typically generated by laboratories providing analytic
 * services in areas such as chemistry, hematology, serology, histology,
 * cytology, anatomic pathology, microbiology, and/or virology. These
 * observations are based on analysis of specimens obtained from the patient and
 * submitted to the laboratory. Imaging results are typically generated by a
 * clinician reviewing the output of an imaging procedure, such as where a
 * cardiologist reports the left ventricular ejection fraction based on the
 * review of a cardiac echocardiogram.
 *
 * Procedure results are typically generated by a clinician to provide more
 * granular information about component observations made during a procedure,
 * such as where a gastroenterologist reports the size of a polyp observed
 * during a colonoscopy.
 *
 * @see Result
 * @see ResultObservation
 * @see CcdCode
 * @see Resident
 */
@Component("consol.ResultsParser")
public class ResultsParser extends AbstractParsableSection<ResultOrganizer, ResultsSection, Result>
        implements ParsableSection<ResultsSection, Result> {

    public static final String LEGACY_TABLE = "Results_NWHIN";

    private final CcdCodeFactory ccdCodeFactory;
    private final ResultObservationFactory resultObservationFactory;

    @Autowired
    public ResultsParser(CcdCodeFactory ccdCodeFactory, ResultObservationFactory resultObservationFactory) {
        this.ccdCodeFactory = ccdCodeFactory;
        this.resultObservationFactory = resultObservationFactory;
    }

    private Result parseResultOrganizer(ResultOrganizer ccdOrganizer, Resident resident) {
        if (!CcdParseUtils.hasContent(ccdOrganizer)) {
            return null;
        }
        checkNotNull(resident);

        final Result result = new Result();
        result.setResident(resident);
        result.setDatabase(resident.getDatabase());
        result.setLegacyId(CcdParseUtils.getFirstIdExtension(ccdOrganizer.getIds()));

        result.setCode(ccdCodeFactory.convert(ccdOrganizer.getCode()));
        if (CcdParseUtils.hasContent(ccdOrganizer.getStatusCode())) {
            result.setStatusCode(ccdOrganizer.getStatusCode().getCode());
        }

        // Read the above comment for @classCode
        result.setClassCode(ccdOrganizer.getClassCode().getName());

        final List<ResultObservation> observations = parseResultObservations(ccdOrganizer, resident);
        result.setObservations(observations);

        if (!CollectionUtils.isEmpty(ccdOrganizer.getProcedures())) {
            // TODO : parse and store procedures ?
        }

        return result;
    }

    private List<ResultObservation> parseResultObservations(ResultOrganizer ccdOrganizer, Resident resident) {
        if (CollectionUtils.isEmpty(ccdOrganizer.getResultObservations())) {
            return Collections.emptyList();
        }
        // TODO test on real examples
        final List<ResultObservation> resultObservations = new ArrayList<>();
        for (Observation ccdObservation : ccdOrganizer.getResultObservations()) {
            final ResultObservation resultObservation = resultObservationFactory.parse(ccdObservation, resident,
                    LEGACY_TABLE);
            if (resultObservation != null) {
                resultObservations.add(resultObservation);
            }
        }
        return resultObservations;
    }

    @Override
    public boolean isSectionIgnored(ResultsSection section) {
        return super.isSectionIgnored(section);
    }

    @Override
    public boolean isEntryIgnored(ResultOrganizer entry) {
        final CS statusCode = entry.getStatusCode();
        final NullFlavor nullFlavor = statusCode.getNullFlavor();
        if (nullFlavor != null && "UNK".equals(nullFlavor.getName())) {
            return true;
        }
        return false;
    }

    @Override
    public List<Result> doParseSection(Resident resident, ResultsSection resultsSection) {
        if (!CcdParseUtils.hasContent(resultsSection) || CollectionUtils.isEmpty(resultsSection.getEntries())) {
            return Collections.emptyList();
        }

        final List<Result> results = new ArrayList<>();
        for (ResultOrganizer ccdResultOrganizer : resultsSection.getConsolResultOrganizers()) {
            if (isEntryIgnored(ccdResultOrganizer)) {
                continue;
            }
            final Result result = parseResultOrganizer(ccdResultOrganizer, resident);
            if (result != null) {
                if (result.getObservations() != null) {
                    result.setObservations(filterResultObservationList(result.getObservations()));
                    results.add(result);
                }
            }
        }
        return results;
    }

    private List<ResultObservation> filterResultObservationList(List<ResultObservation> resultObservations) {
        return FluentIterable.from(resultObservations).filter(new Predicate<ResultObservation>() {
            @Override
            public boolean apply(ResultObservation resultObservation) {
                return StringUtils.isNotEmpty(resultObservation.getText()) && resultObservation.getValue() != null
                        && StringUtils.isNotEmpty(resultObservation.getValue().toString())
                        && StringUtils.isNotEmpty(resultObservation.getValueUnit());
            }
        }).toList();
    }
}
